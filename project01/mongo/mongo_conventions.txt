#########################MONGO SCHEMA###################################

In order to implement a database capable of storing recipes, taking orders, and tracking inventory, I created four collections.
The four collections that I created were a Users collection, an Inventory collection, a Recipes collection, and an Orders collection.
Creating the Users collection was relatively straight forward, although it is worth noting that
I explicitly created unique identifiers myself as part of the data that I loaded into the collection,
rather than having MongoDB do so. This meant that I knew what the unique identifier was for each user, rather than
having MongoDB create random, long ObjectIDs and being forced to work with those. I took the same approach with the Inventory
collection; I assigned a unique ID to each ingredient in the Inventory collection; each ingredient document also had an
inventory quantity total, which is accessed by the 'take_order' function to ensure that Pizzeria_Bob has enough
ingredients to fulfill a particular order. The collection that is most vital in the functionality of this database is the
Recipes collection. In Recipes, there is a unique identifier for each recipe (which I created), and there is also an Ingredients field;
this Ingredients field is an array which contains the ingredients required for each recipe. These ingredients are the same as the unique
identifiers of each ingredient in the Inventory collection, thus creating a relationship between the Inventory collection
and the Recipes collection via the _id field. Also included in each document in the Recipes collection is an array which contains
the quantities of each ingredient that are required to make a particular recipe. The many to many relationship between
Recipes and Inventory is handled by this convention. In addition, in order to know which user had placed what order,
each document in the Orders collection has a userid field that is the same as the userid found in the Users collection,
thus creating a reference using the _id field. In the Orders collection, there is also an order_time field that is automatically
generated by Mongo. This eliminates the possibility of human error in the ordering process, and ensures that orders
are processed in chronological order based on when they are placed.

NOTES:
As mentioned above, I used Python to populate each collection (generate_data.py).
Rather than using mongoimport or a CSV, my script wrote the required number of
insert statements to files for each collection, and then I called those files using the load
commands found beneath each sample insert statement in mongo_code_for_project1.js.
The files containing the raw data can be found in the mongo folder within the project01
folder. Lastly, the index comparisons can be found in the mongo folder in a document titled
Indexing_In_Mongo.txt.
